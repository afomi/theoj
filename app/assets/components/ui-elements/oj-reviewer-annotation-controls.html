<dom-module id="oj-reviewer-annotation-controls">
  <style>

        :host{
        }
        paper-icon-button {
          padding: 2px;
        }
        paper-icon-button::shadow #icon {
          width: 16px;
          height: 16px;
          fill: white;
          stroke: black;
          stroke-width: 1px;
        }
        paper-icon-button[disabled]::shadow #icon {
            fill:   #f6f6f6;
            stroke: #808080;
        }

      </style>
  <template>

      <div class="tools" on-tap="changeState">
          <paper-icon-button id="unresolve" icon="thumb-down" name="Unresolve" title="Unresolved" disabled$="{{_computeDisabled(annotation)}}"></paper-icon-button>
          <paper-icon-button id="resolve" icon="thumb-up" name="Resolve" title="{{_computeDisabled2(annotation)}}" disabled$="{{_computeDisabled(annotation)}}"></paper-icon-button>
          <paper-icon-button id="dispute" icon="report-problem" name="Dispute" title="{{_computeDisabled3(annotation)}}" disabled$="{{_computeDisabled(annotation)}}"></paper-icon-button>
      </div>

      <paper-dialog id="dialog" backdrop="" layered="false">
          <p>Do you really want to <span>{{newState}}</span> this annotation?</p>
          <paper-button affirmative="" autofocus="" on-tap="dialogAccepted">{{newAction}}</paper-button>
          <paper-button dismissive="">Cancel</paper-button>
      </paper-dialog>


      <json-request id="putStateChange" method="put" on-success="putStateChangeSuccess"></json-request>

  </template>
  <script>
    Polymer({
      is: 'oj-reviewer-annotation-controls',
      properties: {
        annotation: {
          notify: true,
          observer: 'annotationChanged'
        },
        paper: {
          notify: true,
          observer: 'paperChanged'
        }
      },
      paperChanged: function () {
        if (!this.paper || !this.annotation)
          return;
        var own_issue = this.paper && this.paper.current_assignment && this.annotation && this.paper.current_assignment.sha == this.annotation.assignment;
        var enabled = this.paper.state == 'under_review' && (own_issue || this.paper.current_role == 'editor');
        enabled ? Polymer.dom(this).removeAttribute('hidden') : Polymer.dom(this).setAttribute('hidden', '');
      },
      annotationChanged: function () {
        this.paperChanged();
      },
      changeState: function (event) {
        event.preventDefault();
        var target = event.target;
        this.newState = target.id;
        this.newAction = target.getAttribute('name');
        if (!this.newAction)
          return;
        this.$.dialog.open();
      },
      dialogAccepted: function () {
        this.set('$.putStateChange.url', Oj.urls.paperAnnotationStateChangePath(this.paper, this.annotation, this.newState));
        this.$.putStateChange.go();
      },
      putStateChangeSuccess: function (event, response) {
        $.extend(this.annotation, response);
        this.fire('annotation-changed', response);
      },
      _computeDisabled: function (annotation) {
        return annotation.state == 'unresolved';
      },
      _computeDisabled2: function (annotation) {
        return annotation.state == 'resolved';
      },
      _computeDisabled3: function (annotation) {
        return annotation.state == 'disputed';
      }
    });
  </script>
</dom-module>
